##### Виртуализация, контейнеризация, контейнеры, виртуальная машина
Виртуализация
это технология, с помощью которой на одном физическом устройстве (компьютере или сервере) можно создать несколько виртуальных компьютеров. Иначе говоря, на компьютере с одной операционной системой можно запустить несколько других операционных систем или приложений.

ОС запускаются в виртуальной среде, что позволяет им работать на одном устройстве изолированно друг от друга

Операционную систему компьютера, на котором работает виртуальная среда, называют хост-системой, а операционную систему, которая запускается в этой виртуальной среде — гостевой системой. Хостовая и гостевая ОС могут иметь взаимоисключающие компоненты, но виртуальная среда позволяет им жить «дружно».

Виртуальная машина (с помощью VirtualBox или VMware)
Виртуализация использует ресурсы устройства (память, процессор, устройство ввода и вывода), но при этом работает как отдельный компьютер со своей операционной системой.

Виртуальные машины работают благодаря аппаратной виртуализации — это способ, при котором в создании изолированной виртуальной среды задействованы гостевые операционные системы.

В основе аппаратной виртуализации лежит работа гипервизора — он отвечает за изоляцию виртуальных сред и распределение ресурсов центральной машины.

##### Контейнерная виртуализация
это способ, при котором виртуальная среда запускается прямо из ядра хостовой операционной системы (то есть мы не устанавливаем другую ОС). В данном случае изоляцию ОС и приложений поддерживает контейнер. Он содержит специальный набор файлов, а также все зависимости запускаемого в нём приложения: код, библиотеки, инструменты и настройки. Всё это упаковано в отдельный образ, работу которого запускает движок (контейнерный движок), например, такой как Docker, CRI-O, Railcar и прочие.

##### Отличие контейнера от виртуальной машины
- В случае с контейнерами у нас есть базовая аппаратная инфраструктура (железо компьютера), операционная система и движок, установленный на этой ОС. Движок управляет контейнерами, которые работают с библиотеками и зависимостями сами, в одиночку.

- В случае виртуальной машины у нас есть ОС на базовом оборудовании (наше железо), затем гипервизор, такой как ESXi, а затем виртуальные машины. У каждой виртуальной машины внутри своя операционная система.

- Эти накладные расходы приводят к более высокому использованию вычислительных ресурсов, поскольку приходится крутить несколько виртуальных операционных систем с их ядрами.

- Виртуальные машины также потребляют больше дискового пространства, поскольку каждая виртуальная машина тяжелая и обычно имеет размер в гигабайтах, тогда как контейнеры легковесны и обычно имеют размер в мегабайтах. Это позволяет контейнерам загружаться быстрее и работать эффективнее.
- При этом ничего не мешает работать с контейнерами на виртуальных машинах.
- адача этой виртуальной машины - запускать контейнеры.

##### Сущности Docker 
Контейнер — это альтернатива и одновременно коллега виртуальной машины. Существуют различные инструменты для работы с контейнерами, одним из которых является Docker.

Docker — это платформа для разработки, запуска и управления контейнерами. Докер позволяет создавать контейнеры, автоматизирует их запуск и управляет жизненным циклом.

Докер состоит из нескольких компонентов:
Docker-host (докер-хост) Это компьютер, на котором работает докер: персональный компьютер, сервер или виртуальная машина в облаке.

Docker-daemon (докер-демон) Это фоновый процесс (”душа докера”), который работает постоянно и ожидает команды. Все операции по управлению контейнерами отправляются именно в демон.

Docker-client (докер-клиент) Это клиент, при помощи которого пользователи взаимодействуют с демоном и отправляют ему команды. Это может быть консоль, API или графический интерфейс. То есть это то, через что мы отправляем запросы докер-демону.

Docker-image (докер-образ) Это неизменяемый образ, из которого разворачивается контейнер. Его можно рассматривать как набор файлов, необходимых для запуска и работы приложения на другом хосте.

Docker-container (докер-контейнер) Это уже развернутое (на основе образа) и запущенное приложение. Продолжая аналогию с установкой ПО, контейнер можно сравнить с уже установленной и работающей программой на ПК (которую установили с диска - образа).

Dockerfile (докер-файл) Это файл-инструкция для сборки образа.

Docker registry Это репозиторий (место), в котором хранятся образы. Docker Hub. Можно создать свой закрытый репозиторий, для использования внутри компании или команды.
Контейнеры Docker получают из образов Docker. По умолчанию Docker загружает эти образы из Docker Hub, реестр Docker, контролируемые Docker, т.е. компанией, реализующей проект Docker. Любой может размещать свои образы Docker на Docker Hub, поэтому большинство приложений и дистрибутивов Linux, которые вам потребуется, хранят там свои образы.

##### Docker-image (Образ) (Images и Сontainer)
Шаблон с набором некоторых инструкций, предназначенных для создания контейнера. Приложения (и всё что им нужно) упаковываются именно в образы, из которых потом уже создаются контейнеры.

Дистрибутив для установки ОС — это Docker image, а установленная и работающая ОС — это Docker container

Docker-Container (Контейнер) — уже собранное, настроенное и запущенное (на основе образа) приложение в изолированной среде.

##### Специальный файл - Dockerfile 
Это инструкция для сборки образа. Это простой текстовый файл, содержащий по одной команде в каждой строке. В нем указываются все программы, зависимости, образы, и команды которые нужны для создания контейнера.

```
FROM python:3.7.2-alpine3.8
LABEL maintainer="pylounge@mail.ru"
# Устанавливаем зависимости
RUN apt-get install git
# Задаём текущую рабочую директорию
WORKDIR /usr/src/my_app_directory
# Копируем код из локального контекста в рабочую директорию образа
COPY . .
# Задаём значение по умолчанию для переменной
ARG my_var=my_default_value
# Настраиваем команду, которая должна быть запущена в контейнере во время его выполнения
ENTRYPOINT ["python", "./app/my_script.py", "my_var"]
# Открываем порты
EXPOSE 8000
# Создаём том для хранения данных
VOLUME /my_volume
```

Созданные на основе Dockefile образы, для дальнейшего распространения, загружают в Docker репозитории

Когда образов и контейнеров становится много и возможностей одного докера не хватает, на помощь ему приходят дополнительные инструменты в лице 
Docker Compose и Docker Swarm и Kubernetes

##### Docker-compose
Docker-compose - инструмент, который позволяет разворачивать и настраивать несколько контейнеров одновременно. 
Например, для веб-приложения нужно развернуть стек LAMP: Linux, Apache, MySQL, PHP. Каждое из приложений — это отдельный контейнер
Docker-compose позволяет развернуть и настроить все приложения одной командой

##### Docker Swarm - оркестрация

Оркестровка — это управление и координация взаимодействия между контейнерами. Контейнеры запускаются на хостах, а хосты объединяют в кластер.

У Docker есть стандартный инструмент оркестровки — Docker Swarm Mode, или просто Docker Swarm. Он поставляется «из коробки»

Управление всеми этими контейнерами может быть большой головной болью. 
Он легко управляет и управляет кластером, в котором работают несколько докер-контейнеров.

Docker Swarm Mode - это про кластеры и оркестрацию. Можно запустить много экземпляров одного контейнера на нескольких разных машинах. 

Docker-compose - это просто про запуск нескольких (разных) контейнеров вместе на одной машине.

##### Kubernetes
Это сложная система, которая позволяет построить отказоустойчивую и масштабируемую платформу для управления контейнерами. Он умеет работать не только с контейнерами Docker, но и с другими контейнерами: rkt, CRI-O

Kubernates похож на Docker Swarm. Однако служба Kubernetes более обширна, чем Docker Swarm, и предназначена для эффективной координации кластеров узлов в масштабировании в процессе производства.

##### Установка Docker для ОС Linux (Ubuntu 20.04)
Обновите существующий список пакетов Ubuntu
`sudo apt-get update`
`sudo apt-get upgrade`

Установите пакеты, которые позволяют  apt-get  работать с репозиториями через HTTPS
```
sudo apt-get install \ 
	ca-certificates \
	curl \ 
	gnupg \ 
	lsb-release```
```
Добавьте ключ GPG для официального репозитория Docker:
`curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -`
Добавьте репозиторий Docker в источники apt-get
`sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu focal stable"`
Обновите базу данных пакетов и добавьте в нее пакеты Docker из добавленного репозитория:
`sudo apt-get update`
Установите Docker через менеджер apt-get
`sudo apt install docker-ce`
Убедимся, что установка прошла успешно, проверив статус службы
`sudo systemctl status docker`

##### Основы работы с Docker
Полный список команд выглядит следующим образом:
`docker [option] [command] [arguments]`
```
attach Attach local standard input, output, and error streams to a running container
build Build an image from a Dockerfile
commit Create a new image from a container's changes
cp Copy files/folders between a container and the local filesystem
create Create a new container
diff Inspect changes to files or directories on a container's filesystem
events Get real time events from the server
exec Run a command in a running container
export Export a container's filesystem as a tar archive
history Show the history of an image
images List images
import Import the contents from a tarball to create a filesystem image
info Display system-wide information
inspect Return low-level information on Docker objects
kill Kill one or more running containers
load Load an image from a tar archive or STDIN
login Log in to a Docker registry
logout Log out from a Docker registry
logs Fetch the logs of a container
pause Pause all processes within one or more containers
port List port mappings or a specific mapping for the container
ps List containers
pull Pull an image or a repository from a registry
push Push an image or a repository to a registry
rename Rename a container
restart Restart one or more containers
rm Remove one or more containers
rmi Remove one or more images
run Run a command in a new container
save Save one or more images to a tar archive (streamed to STDOUT by default)
search Search the Docker Hub for images
start Start one or more stopped containers
stats Display a live stream of container(s) resource usage statistics
stop Stop one or more running containers
tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE
top Display the running processes of a container
unpause Unpause all processes within one or more containers
update Update configuration of one or more containers
version Show the Docker version information
wait Block until one or more containers stop, then print their exit codes
```
Чтобы просмотреть параметры, доступные для конкретной команды, введите: 
`docker docker-command --help`

##### Установка Nextcloud
- `docker pull nextcloud` загрузить его на свой компьютер с помощью команды  pull
- `docker images` образы, которые были загружены
- `docker run nextcloud`  запустить контейнер (созданный на основе этого образа)
- `docker run -d -p 8080:80 nextcloud` можно передавать дополнительные опции и параметры, влияющие на запуск контейнера. Cервис был доступен на порту 8080
`-d` - запустить контейнер в автономном режиме (в фоновом режиме)
`-p 8080:80` - сопоставить порт 8080 хоста с портом 80 в контейнере.
- IP-адрес компьютера можно посмотреть с помощью команды ifconfig (или ip addr ) на ОС семейства Linux
- Активные (запущенные в данный момент) контейнеры, используйте следующую команду docker ps
- Просмотреть все контейнеры — активные и неактивные `docker ps -a`
- Остановить (выключить) запущенный контейнер, используют команду `docker stop`  с идентификатором контейнера (CONTAINER ID) или именем контейнера (NAMES).
- Запустить остановленный контейнер можно с помощью команды `docker start` с указанием идентификатором контейнера (CONTAINER ID) или именем контейнера (NAMES)
- Если контейнер больше вам не нужен, то удалите его с помощью команды  docker rm , снова добавив идентификатор контейнера или его имя.
- Выполнить "вход" внутрь контейнер для внесения в него изменений (редактирование файлов конфигурации, установка программ и т.д.) можно с помощью команды `exec` и комбинации флагов `-it` : `docker exec -it e176ec2e0cd6bash bash`
- Выйдем из из интерактивного режима с помощью команды exit .
- Любые изменения, которые внесены внутри контейнера, применяются только к контейнеру.
- После запуска образа Docker можно создавать, изменять и удалять файлы так же, как и с помощью виртуальной машины.
- Можно запускать и останавливать контейнер, но после того как он будет удалён с помощью команды  docker rm , изменения будут утрачены навсегда.
`docker commit -m "Комментарий" -a "Кто изменил" container_id repository/new_image_name`
Переключатель `-m` используется в качестве сообщения о внесении изменений

Создавать образы из  Dockerfile , что позволяет автоматизировать установку программного обеспечения в новом образе
Запускаем контейнер с обновлённым образом: `docker run -d -p 8080:80 nextcloud_with_txt`

##### Загрузка образов Docker в репозиторий Docker (Docker Hub)
`docker login -u docker-registry-username` выполнить вход в Docker Hub
`docker tag peoples/nextcloud_with_txt docker-registry-username/nextcloud_with_txt` пометить ваш образ именем пользователя в реестре
`docker push pylounge/nextcloud_with_txt` загрузить образ с помощью следующей команды
`docker pull pylounge/nextcloud_with_txt` загрузить образ на новый компьютер и использовать его для запуска нового контейнера

##### Создание Docker образа с приложением на Python
Создание Flask приложения
Для начала создадим простое Flask-приложение.
создать пустой каталог для нашего проекта, в котором будут содержаться все файлы проекта.
Внутри каталога создать виртуальное окружение и активировать его

```yaml
$ mkdir pylounge_docker_project 
$ cd pylounge_docker_project/ 
$ /pylounge_docker_project$ sudo apt-get install python3.8-venv 
$ pylounge_docker_project$ python3 -m venv env 
$ pylounge_docker_project$ source env/bin/activate
```
Установим Flask : `python -m pip install flask`
Создадим отдельную директорию, в которой будет находиться само Flask-приложение : `mkdir pylounge_flask_app`
Сохраните список установленных в окружении пакетов в requirements.txt в каталоге приложения : `pip freeze > pylounge_flask_app/requirements.txt`
Создайте файл app.py в каталоге pylounge_flask_app, который будет содержать простое python Flask Web-приложение: `sudo nano pylounge_flask_app/app.py`

И добавим туда следующий программный код на языке Python:
```yaml
#!/usr/bin/env python
# -*- coding: utf-8 -*-
from flask import Flask
app = Flask(__name__)
@app.route('/')
def hello_world():
return 'Hello from PyLounge and Docker!'
if __name__ == '__main__':
app.run(debug=True, host='0.0.0.0', port=5000)
```
Проверим работоспособность приложения, запустив его командой:
`python pylounge_flask_app/app.py`

В адресной строке веб-браузера введём  http://127.0.0.1:5000/

##### Упаковка Flask приложения в контейнер Dockerfile
- Cоздания Docker образа (Docker-image) используется специальный Dockerfile
- Dockerfile  — это текстовый файл, в котором описан рецепт создания образа Docker. Рецепт состоит из инструкций, которые выполняются последовательно. Они содержат информацию об операционной системе, выбранной платформе, фреймворках, библиотеках, инструментах, которые нужно установить

Структура Dockerfile
`FROM`  — задаёт родительский (главный) образ;
`LABEL`  — добавляет метаданные для образа. Хорошее место для размещения информации об авторе;
`ENV`  — создаёт переменную окружения;
`RUN`  — запускает команды, создаёт слой образа. Используется для установки пакетов и библиотек внутри контейнера;
`COPY` — копирует файлы и директории в контейнер;
`ADD` — делает всё то же, что и инструкция  `COPY` . Но ещё может распаковывать локальные  .tar  файлы;
`CMD`  — указывает команду и аргументы для выполнения внутри контейнера. Параметры могут быть переопределены.
Использоваться может только одна инструкция  `CMD` ;
`WORKDIR`  — устанавливает рабочую директорию для инструкции  `CMD`  и  `ENTRYPOINT` ;
`ARG`  — определяет переменную для передачи Docker’у во время сборки;
`ENTRYPOINT`  — предоставляет команды и аргументы для выполняющегося контейнера. Суть его несколько отличается
от  `CMD` , о чём мы поговорим ниже;
`EXPOSE`  — открывает порт;
`VOLUME`  — создаёт точку подключения директории для добавления и хранения постоянных данных.

Создадим Dockerfile в директории pylounge_flask_app:
`sudo nano pylounge_flask_app/Dockerfile`
Содержимое Dockerfile файла в нашем случае будет следующим:
```yaml
FROM ubuntu:latest
MAINTAINER Maxim Melnikov 'pylounge@mail.ru'
RUN apt-get update -qy
RUN apt-get install -qy python3.8 python3-pip python3.8-dev
COPY . /app
WORKDIR /app
RUN pip install -r requirements.txt
CMD ["python3","app.py"]
```

Описание инструкций Dockerfile
- FROM ubuntu:latest В качестве базового образа будет использоваться latest версия образа Ubuntu (то есть мы создаем наш образ на основе образа ubuntu из Docker Hub)
- MAINTAINER Maxim Melnikov 'pylounge@mail.ru' Справочная информация об авторе образа. Не обязательный параметр
- RUN apt-get update -qy Обновить информацию о репозиториях внутри контейнера
- RUN apt-get install -qy python3.8 python3-pip python3.8-dev Установить внутрь контейнера пакеты: python3.8 python3-pip, python3.8-dev
- COPY . /app Скопировать содержимое текущей директории «.» в директорию /app внутри образа. Внимание: текущей директорией в процессе сборки будет считаться директория, содержащая Dockerfile, т.е. в нашем случае pylounge_flask_app/
- WORKDIR /app Сменить рабочую директорию внутри контейнера. Все команды далее будут запускаться внутри директории /app внутри контейнера
- RUN pip install -r requirements.txt Установить зависимости, сохраненные вами в requirements.txt через pip freeze. Данная команда установить Flask и все, что необходимо для его запуска внутри контейнера
- CMD ["python3","app.py"] Интерпретатору python будет передан дополнительный аргумент app.py. Другими словами, во время запуска контейнера последней инструкцией будет выполнена команда python3 app.py из директории /app

Создание образа контейнера на основе Dockerfile
- Для создания собственного контейнера, содержащего созданное Flask приложение, на основе также созданного нами Dockerfile, находясь внутри директории pylounge_docker_project необходимо выполнить команду build :
`sudo docker build -t pylounge_flask_app:v1 pylounge_flask_app/`
Ключ -t предназначен для того, чтобы присвоить вашему образу метку (label) «pylounge_flask_app» и его версию «v1». Метка и версия могут быть произвольными.

В процессе выполнения команды как описано в Dockerfile будет произведена загрузка последнего образа ubuntu, внутри него установлены все необходимые зависимости, создана директория /app , в которую будет помещено содержимое директории pylounge_flask_app/ , установлены все зависимости из файла requirements.txt , а сам образ настроен на запуск вашего Flask приложения из директории /app , находящейся внутри образа.

После успешного выполнения команды в списке образов появится только что созданный образ `pylounge_flask_app:v1`
Для запуска Docker контейнера из подготовленного образа необходимо выполнить команду
```yaml
`sudo docker run -it -p 5000:5000 pylounge_flask_app:v1 
// либо 
sudo docker run -d -p 5000:5000 pylounge_flask_app:v1
```
Ключ` -d` предназначен для запуска вашего контейнера в фоновом режиме (необходим для того, чтобы вернуть управление терминалу, в котором вы работаете).
	`-i`  интерактивный режим
	`-t`  подключает виртуальный терминал
Ключ `-p` заставит Docker Machine пробрасывать подключения, приходящие на порт 5000 внешнего адреса Docker Machine на порт 5000 контейнера, на котором будет слушать подключения ваше Flask приложение.

Таким образом наш контейнер готов. Теперь мы можем разворачивать наше приложения на различных компьютерах, не боясь “ада зависимостей”, а также выложить образ на Docker Hub.